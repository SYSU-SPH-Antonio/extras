---
title: "Intro a Spatial Data Science con R"
author: "Alí Santacruz"
date: "July 13, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
```

<br>

Hay una gran cantidad de paquetes de R utiles para trabajar con datos espaciales. Para los ejemplos de este documento se requiere tener los siguientes: 

```{r install, eval = FALSE}
install.packages(c("rgdal"))
```

<br>


## The Data Science Process

![](images/data_science_process.jpg)

<br>


#### **1. PLANTEAR las preguntas apropiadas** 

Ver las diapositivas.

<br>

#### **2. OBTENER los datos**  


*a. Importar capas vector*

Archivos vector pueden ser importados con el paquete **[rgdal]** como objetos de clase Spatial___DataFrame:

```{r rgdal, warning = FALSE}
library(rgdal)
myShp <- readOGR("data/llanos.shp", layer = "llanos")
summary(myShp)

# Ejemplo KML
# myKML <- readOGR("data/llanos_kml.kml", layer = "llanos_kml")
```

Shapefiles tambien pueden ser importados con el comando `shapefile` del paquete **[raster]** de manera mas simple:

```{r raster_shp, warning = FALSE}
library(raster)
shp <- shapefile("data/llanos.shp")
shp
spplot(shp)
```


Visualizar con **[mapview]**

Run devtools::install_github('rstudio/leaflet') to fix this issue.

```{r warning = FALSE}
library(mapview)
mapView(shp)
```

<br>

*b. Importar capas raster*  

Haciendo uso del paquete **[raster]**: archivos de una sola capa se importan con el comando `raster`, archivos con multiples capas se pueden importar con los comandos `stack` o `brick`:

```{r raster_raster}
miTIFF <- raster("data/cropimg.tif")
miTIFF
plot(miTIFF)
```



Visualizar con mapview: slideView (correr en la consola):

```{r, eval = FALSE}
data(poppendorf)
stck1 <- subset(poppendorf, c(3, 4, 5))
stck2 <- subset(poppendorf, c(2, 3, 4))
slideView(stck1, stck2)
```

Visualizar con mapview: cubeView (correr en la consola)

```{r, eval = FALSE}
kili_data <- system.file("extdata", "kiliNDVI.tif", package = "mapview")
kiliNDVI <- stack(kili_data)
cubeView(kiliNDVI)
```

<br>

*c. Obtener datos georreferenciados usando APIs*

ver [post Twitter] y lanzar [twitter-r Shiny app]

```{r eval = FALSE}
library(twitteR)
tweets <- twListToDF(searchTwitter("#dinner", n = 100, geocode = paste0("40.75,-74,10km")))
tweets
```

<br>

*d. Descargar imagenes satelitales/informacion geografica*

Por ejemplo, es posible  descargar escenas completas de MODIS usando el paquete **[modis]**. Se puede tambien descargar subconjuntos de datos de MODIS usando el paquete **[MODISTools]**:

```{r, eval = FALSE}
library(MODISTools)
data(SubsetExample)
MODISSubsets(LoadDat = SubsetExample, Products = "MOD13Q1", Bands = c("250m_16_days_EVI",
"250m_16_days_pixel_reliability"), Size = c(0,0), StartDate = TRUE)
```

<br>

La funcion [getData] del paquete **[raster]** permite descargar varios datasets, entre ellos, 'GADM', 'countries', 'SRTM', 'alt', y 'worldclim'.

<br>

#### **3. PREPARAR los datos**  

*a. Data cleaning*

Archivos vect

<br>

*b. Operaciones vector*

Por ejemplo, operaciones como union, interseccion o punto en poligono pueden ser llevadas a cabo con el paquete **[raster]**: 

```{r}
p <- shapefile(system.file("external/lux.shp", package="raster"))
b <- as(extent(6, 6.4, 49.75, 50), 'SpatialPolygons')
projection(b) <- projection(p)
i <- intersect(p, b)
```

<br>

*c. Operaciones raster*

El paquete **[raster]** tambien permite realizar de manera facil operaciones raster de analisis espacial como algebra de mapas, aplicacion de filtros, entre muchas otras, por ejemplo:

```{r}
r <- raster(ncol=10, nrow=10)
r1 <- init(r, fun=runif)
r2 <- init(r, fun=runif)
r3 <- overlay(r1, r2, fun=function(a,b){return(a*b+a)} )  

# funcion equivalente, eficiente si los valores pueden ser cargados en la memoria
r4 <- r1 * r2 + r1
```

<br>

#### **4. EXPLORAR los datos** 

*a. Estadisticas descriptivas*

Analizar las estadisticas descriptivas de los datos:

```{r}
vis <- shapefile("data/ba_LC80940792015255LGN00_sr.shp")@data
summary(vis[, 13:20])
```

<br>

*b. Graficos exploratorios*

Analizar el diagrama de dispersión en 2D:

```{r}
library(ggplot2)
p <- qplot(vis$evi, vis$ndvi, color = vis$Landtype, shape = vis$Landtype, 
             main = "EVI vs. NDVI", xlab = "EVI", ylab = "NDVI") + geom_point(size = 4) +
    guides(colour = guide_legend("Type"), shape = guide_legend("Type"))
p
```

Analizar el diagrama de dispersión en 3D:

```{r}
library(rgl)
with(vis, plot3d(XCOORD, YCOORD, ndvi, col = as.numeric(as.factor(Landtype))))
```

<br>

*c. Autocorrelacion espacial*

Calcular el test Moran's I para autocorrelacion espacial global:

```{r}
library(spdep)
data(oldcol)
coords.OLD <- cbind(COL.OLD$X, COL.OLD$Y)
moran.test(COL.OLD$CRIME, nb2listw(COL.nb, style="B"))
```

Calcular el test Local G (estadistico Gi) para autocorrelacion espacial:

```{r}
data(getisord)
xycoords <- cbind(xyz$x, xyz$y)
nb30 <- dnearneigh(xycoords, 0, 30)
G30 <- localG(xyz$val, nb2listw(nb30, style="B"))
brks <- seq(-5,5,1)
cm.col <- cm.colors(length(brks)-1)
image(x, y, t(matrix(G30, nrow=16, ncol=16, byrow=TRUE)), breaks=brks, col=cm.col, asp=1)
text(xyz$x, xyz$y, round(G30, digits=1), cex=0.7)
polygon(c(195,225,225,195), c(195,195,225,225), lwd=2)
title(main=expression(paste("Values of the ", G[i], " statistic")))
```

<br>

#### **5. MODELAR los datos**

*a. Regresion*

ejemplo spdep

```{r sarlm, warning = FALSE}
library(spdep)
data(oldcol)
COL.lag.eig <- lagsarlm(CRIME ~ INC + HOVAL, data = COL.OLD, listw = nb2listw(COL.nb, style="W"), method = "eigen")
summary(COL.lag.eig, correlation=TRUE)
```

<br>

*b. Clasificacion (Machine Learning)*

Las tecnicas de Machine Learning para clasificacion (RandomForests, SVM, etc) se pueden aplicar tanto a datos vector como a datos raster. ejemplo clasificacion raster. Primero importamos la imagen y el shapefile con las areas de entrenamiento:

```{r eval = FALSE}
img <- brick("data/L7007057_20000316_refl")
names(img) <- c(paste0("B", 1:5, coll = ""), "B7")
trainData <- shapefile("C:/data/landsat/shps/UTM18N_32618/training_15.shp")
responseCol <- "class"
```

Luego extraemos de la imagen los valores de los pixeles para cada banda y para cada clase en las areas de entrenamiento:

```{r eval = FALSE}
dfAll = data.frame(matrix(vector(), 0, length(names(img)) + 1))
for (i in 1:length(unique(trainData[[responseCol]]))){
  category <- unique(trainData[[responseCol]])[i]
  categorymap <- trainData[trainData[[responseCol]] == category,]
  dataSet <- extract(img, categorymap)
  dataSet <- lapply(dataSet, function(x){cbind(x, class = as.numeric(rep(category, nrow(x))))})
  df <- do.call("rbind", dataSet)
  dfAll <- rbind(dfAll, df)
}
sdfAll <- subset(dfAll[sample(1:nrow(dfAll), nsamples), ])
```

Ajustamos el modelo con la tecnica de Machine Learning escogida, en este caso RandomForests, y realizamos la clasificacion (prediccion):

```{r eval = FALSE}
modFit_rf <- train(as.factor(class) ~ B3 + B4 + B5, method = "rf", data = sdfAll)
preds_rf <- raster::predict(img, modFit_rf)
```

<br>

*c. Estadistica espacial: Geoestadistica, Patrones de puntos espaciales*

Ejemplo geoestadistica (correr en R GUI):

```{r geospt, eval = FALSE}
library(geospt)
example(simPtsOptNet)
```

<br>

#### **6. COMUNICAR los resultados**

Con R cada vez es mas sencillo generar mapas tematicos de calidad. Un paquete que nos puede ayudar en esa tarea es **[tmap]**:

```{r thematic_map}
library(tmap)
data(land, World)
tm_shape(land, projection="eck4") +
    tm_raster("elevation", breaks=c(-Inf, 250, 500, 1000, 1500, 2000, 2500, 3000, 4000, Inf),
        palette = terrain.colors(9), title="Elevation", auto.palette.mapping=FALSE) +
tm_shape(World) +
    tm_borders("grey20") +
    tm_grid(projection="longlat", labels.size = .5) +
    tm_text("name", size="AREA") +
tm_compass(position = c(.65, .15), color.light = "grey90") +
tm_credits("Eckert IV projection", position = c(.85, 0)) +
tm_style_classic(inner.margins=c(.04,.03, .02, .01), legend.position = c("left", "bottom"),
    legend.frame = TRUE, bg.color="lightblue", legend.bg.color="lightblue",
    earth.boundary = TRUE, space.color="grey90")
```

Con paquetes como **[shiny]** y **[flexdashboard]** podemos ahora desarrollar facilmente aplicaciones web que permitan a los usuarios manipular, visualizar e interactuar con los datos y los resultados de nuestros modelos. 

Ejemplo Shiny app: Numero de vehiculos de buses por rutas para un area urbana: [http://shiny.rstudio.com/gallery/bus-dashboard.html].

Ejemplo Shiny/flexdashboard app: Explorar la diversidad de los vecindarios para un area metropolitana dada: [https://walkerke.shinyapps.io/neighborhood_diversity/].


El codigo fuente de este documento escrito en RMarkdown se puede descargar desde [https://github.com/amsantac/extras] (usar el boton 'Clone or Download') de la carpeta '2016-07-13-spatial-data-science-r-webinar'


ftp://ftp.bgc-jena.mpg.de/pub/outgoing/mforkel/Rcourse/spatialR_2015.pdf
R-SIG-Geo mailing list

[rgdal]: https://cran.r-project.org/web/packages/rgdal/index.html
[raster]: https://cran.r-project.org/web/packages/raster/index.html
[getData]: http://search.r-project.org/usr/share/doc/library/raster/html/getData.html
[tmap]: https://cran.r-project.org/web/packages/tmap/index.html
[mapview]: https://cran.r-project.org/web/packages/mapview/index.html
[shiny]: https://cran.r-project.org/web/packages/shiny/index.html
[flexdashboard]: https://cran.r-project.org/web/packages/flexdashboard/index.html
[post Twitter]: http://amsantac.co/blog/es/2016/05/28/twitter-r-es.html
[twitter-r Shiny app]: https://amsantac.shinyapps.io/twitter-r/
[modis]: http://r-forge.r-project.org/R/?group_id=1252
[MODISTools]: https://cran.r-project.org/web/packages/MODISTools/index.html
[http://shiny.rstudio.com/gallery/bus-dashboard.html]: http://shiny.rstudio.com/gallery/bus-dashboard.html
[https://walkerke.shinyapps.io/neighborhood_diversity/]: https://walkerke.shinyapps.io/neighborhood_diversity/
[https://github.com/amsantac/extras]: https://github.com/amsantac/extras

